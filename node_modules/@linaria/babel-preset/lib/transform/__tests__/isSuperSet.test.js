"use strict";

var _Entrypoint = require("../Entrypoint.helpers");
describe('isSuperSet', () => {
  it('should be defined', () => {
    expect(_Entrypoint.isSuperSet).toBeDefined();
  });
  it('should return true if the first set is a superset of the second', () => {
    expect((0, _Entrypoint.isSuperSet)([1, 2, 3], [1, 2])).toBe(true);
  });
  it('should return false if the first set is not a superset of the second', () => {
    expect((0, _Entrypoint.isSuperSet)([1, 2], [1, 2, 3])).toBe(false);
  });
  it('should return true if the first set is equal to the second', () => {
    expect((0, _Entrypoint.isSuperSet)([1, 2, 3], [1, 2, 3])).toBe(true);
  });
  it('should return false if the first set is empty', () => {
    expect((0, _Entrypoint.isSuperSet)([], [1, 2, 3])).toBe(false);
  });
  it('should return true if the second set is empty', () => {
    expect((0, _Entrypoint.isSuperSet)([1, 2, 3], [])).toBe(true);
  });
  it('should return true if both sets are empty', () => {
    expect((0, _Entrypoint.isSuperSet)([], [])).toBe(true);
  });
  it('should return true if the first set is a superset of the second with duplicates', () => {
    expect((0, _Entrypoint.isSuperSet)([1, 2, 3], [1, 2, 2, 2, 1, 3])).toBe(true);
  });
  it('should return true if the first has a wildcard', () => {
    expect((0, _Entrypoint.isSuperSet)(['*', 1], [1, 2, 3])).toBe(true);
  });
  it('should return false if the second has a wildcard', () => {
    expect((0, _Entrypoint.isSuperSet)([1, 2, 3], ['*'])).toBe(false);
  });
  it('should return true if both have wildcards', () => {
    expect((0, _Entrypoint.isSuperSet)(['*', 1, 2], ['*'])).toBe(true);
  });
});
//# sourceMappingURL=isSuperSet.test.js.map