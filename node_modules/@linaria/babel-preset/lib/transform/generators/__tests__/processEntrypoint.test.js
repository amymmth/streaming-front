"use strict";

var _entrypointHelpers = require("../../__tests__/entrypoint-helpers");
var _processEntrypoint = require("../processEntrypoint");
var _helpers = require("./helpers");
describe('processEntrypoint', () => {
  let services;
  beforeEach(() => {
    services = (0, _entrypointHelpers.createServices)();
  });
  it('should emit explodeReexports, transform and finalizeEntrypoint actions', () => {
    const fooBarDefault = (0, _entrypointHelpers.createEntrypoint)(services, '/foo/bar.js', ['default']);

    // const action = createAction('processEntrypoint', fooBarDefault, {}, null);
    const action = fooBarDefault.createAction('processEntrypoint', undefined, null);
    const gen = _processEntrypoint.processEntrypoint.call(action);
    let result = gen.next();
    (0, _helpers.expectIteratorYieldResult)(result);
    expect(result.value[0]).toBe('explodeReexports');
    expect(result.value[1]).toBe(fooBarDefault);
    result = gen.next();
    (0, _helpers.expectIteratorYieldResult)(result);
    expect(result.value[0]).toBe('transform');
    expect(result.value[1]).toBe(fooBarDefault);
    (0, _helpers.expectIteratorReturnResult)(gen.next(), undefined);
  });
  it('should abort previously emitted actions if entrypoint was superseded and emit a new processEntrypoint', () => {
    const fooBarDefault = (0, _entrypointHelpers.createEntrypoint)(services, '/foo/bar.js', ['default']);
    const action = fooBarDefault.createAction('processEntrypoint', undefined, null);
    const gen = _processEntrypoint.processEntrypoint.call(action);
    const emitted = [gen.next(), gen.next()].filter(_helpers.isIteratorYieldResult).map(result => result.value);
    expect(emitted[0][0]).toBe('explodeReexports');
    expect(emitted[1][0]).toBe('transform');
    const emittedSignals = emitted.map(a => a[3]);
    expect(emittedSignals.map(signal => signal === null || signal === void 0 ? void 0 : signal.aborted)).toEqual([false, false]);
    const supersededWith = (0, _entrypointHelpers.createEntrypoint)(services, '/foo/bar.js', ['named']);
    expect(emittedSignals.map(signal => signal === null || signal === void 0 ? void 0 : signal.aborted)).toEqual([true, true]);
    const nextResult = gen.next();
    (0, _helpers.expectIteratorYieldResult)(nextResult);
    expect(nextResult.value[0]).toBe('processEntrypoint');
    expect(nextResult.value[1]).toBe(supersededWith);
  });
  it('should abort previously emitted actions if parent aborts', () => {
    const fooBarDefault = (0, _entrypointHelpers.createEntrypoint)(services, '/foo/bar.js', ['default']);
    const abortController = new AbortController();
    const action = fooBarDefault.createAction('processEntrypoint', undefined, abortController.signal);
    const gen = _processEntrypoint.processEntrypoint.call(action);
    const emitted = [gen.next(), gen.next()].filter(_helpers.isIteratorYieldResult).map(result => result.value);
    expect(emitted[0][0]).toBe('explodeReexports');
    expect(emitted[1][0]).toBe('transform');
    const emittedSignals = emitted.map(a => a[3]);
    expect(emittedSignals.map(signal => signal === null || signal === void 0 ? void 0 : signal.aborted)).toEqual([false, false]);
    abortController.abort();
    expect(emittedSignals.map(signal => signal === null || signal === void 0 ? void 0 : signal.aborted)).toEqual([true, true]);
    (0, _helpers.expectIteratorReturnResult)(gen.next(), undefined);
  });
});
//# sourceMappingURL=processEntrypoint.test.js.map