{"version":3,"file":"resolveImports.js","names":["getFileIdx","getStack","isSuperSet","mergeOnly","emitDependency","emitter","entrypoint","imports","single","type","file","name","only","map","resolved","from","what","fileIdx","toString","padStart","filterUnresolved","resolvedImports","filter","i","log","source","syncResolveImports","resolve","data","services","eventEmitter","listOfImports","Array","entries","length","err","filteredImports","asyncResolveImports","getResolveTask","Promise","all","importsOnly","cached","getDependency","task","newTask","then","res","merged","addResolveTask","resolveTask"],"sources":["../../../src/transform/generators/resolveImports.ts"],"sourcesContent":["/* eslint-disable no-continue,no-await-in-loop,require-yield */\nimport { getFileIdx } from '@linaria/utils';\n\nimport type { Entrypoint } from '../Entrypoint';\nimport { getStack, isSuperSet, mergeOnly } from '../Entrypoint.helpers';\nimport type { IEntrypointDependency } from '../Entrypoint.types';\nimport type {\n  AsyncScenarioForAction,\n  IResolveImportsAction,\n  Services,\n  SyncScenarioForAction,\n} from '../types';\n\nfunction emitDependency(\n  emitter: Services['eventEmitter'],\n  entrypoint: IResolveImportsAction['entrypoint'],\n  imports: IEntrypointDependency[]\n) {\n  emitter.single({\n    type: 'dependency',\n    file: entrypoint.name,\n    only: entrypoint.only,\n    imports: imports.map(({ resolved, only }) => ({\n      from: resolved,\n      what: only,\n    })),\n    fileIdx: getFileIdx(entrypoint.name).toString().padStart(5, '0'),\n  });\n}\n\nfunction filterUnresolved(\n  entrypoint: Entrypoint,\n  resolvedImports: IEntrypointDependency[]\n): IEntrypointDependency[] {\n  return resolvedImports.filter((i): i is IEntrypointDependency => {\n    if (i.resolved === null) {\n      entrypoint.log(\n        `[resolve] ✅ %s in %s is ignored`,\n        i.source,\n        entrypoint.name\n      );\n      return false;\n    }\n\n    return true;\n  });\n}\n\n/**\n * Synchronously resolves specified imports with a provided resolver.\n */\nexport function* syncResolveImports(\n  this: IResolveImportsAction,\n  resolve: (what: string, importer: string, stack: string[]) => string\n): SyncScenarioForAction<IResolveImportsAction> {\n  const {\n    data: { imports },\n    entrypoint,\n    services: { eventEmitter },\n  } = this;\n  const listOfImports = Array.from(imports?.entries() ?? []);\n  const { log } = entrypoint;\n\n  if (listOfImports.length === 0) {\n    emitDependency(eventEmitter, entrypoint, []);\n\n    log('%s has no imports', entrypoint.name);\n    return [];\n  }\n\n  const resolvedImports = listOfImports.map(([source, only]) => {\n    let resolved: string | null = null;\n    try {\n      resolved = resolve(source, entrypoint.name, getStack(entrypoint));\n      log('[sync-resolve] ✅ %s -> %s (only: %o)', source, resolved, only);\n    } catch (err) {\n      log('[sync-resolve] ❌ cannot resolve %s: %O', source, err);\n    }\n\n    return {\n      source,\n      only,\n      resolved,\n    };\n  });\n\n  const filteredImports = filterUnresolved(entrypoint, resolvedImports);\n  emitDependency(eventEmitter, entrypoint, filteredImports);\n\n  return filteredImports;\n}\n\n/**\n * Asynchronously resolves specified imports with a provided resolver.\n */\nexport async function* asyncResolveImports(\n  this: IResolveImportsAction,\n  resolve: (\n    what: string,\n    importer: string,\n    stack: string[]\n  ) => Promise<string | null>\n): AsyncScenarioForAction<IResolveImportsAction> {\n  const {\n    data: { imports },\n    entrypoint,\n    services: { eventEmitter },\n  } = this;\n  const listOfImports = Array.from(imports?.entries() ?? []);\n  const { log } = entrypoint;\n\n  if (listOfImports.length === 0) {\n    emitDependency(eventEmitter, entrypoint, []);\n\n    log('%s has no imports', entrypoint.name);\n    return [];\n  }\n\n  log('resolving %d imports', listOfImports.length);\n\n  const getResolveTask = async (\n    source: string,\n    only: string[]\n  ): Promise<IEntrypointDependency> => {\n    let resolved: string | null = null;\n    try {\n      resolved = await resolve(source, entrypoint.name, getStack(entrypoint));\n    } catch (err) {\n      log(\n        '[async-resolve] ❌ cannot resolve %s in %s: %O',\n        source,\n        entrypoint.name,\n        err\n      );\n    }\n\n    if (resolved !== null) {\n      log(\n        '[async-resolve] ✅ %s (%o) in %s -> %s',\n        source,\n        only,\n        entrypoint.name,\n        resolved\n      );\n    }\n\n    return {\n      source,\n      only,\n      resolved,\n    };\n  };\n\n  const resolvedImports = await Promise.all<IEntrypointDependency>(\n    listOfImports.map(([source, importsOnly]) => {\n      const cached = entrypoint.getDependency(source);\n      if (cached) {\n        return {\n          source,\n          only: mergeOnly(cached.only, importsOnly),\n          resolved: cached.resolved,\n        };\n      }\n\n      const task = entrypoint.getResolveTask(source);\n      if (task) {\n        // If we have cached task, we need to merge only…\n        const newTask = task.then((res) => {\n          if (isSuperSet(res.only, importsOnly)) {\n            return res;\n          }\n\n          // Is this branch even possible?\n          const merged = mergeOnly(res.only, importsOnly);\n\n          log('merging imports %o and %o: %o', importsOnly, res.only, merged);\n\n          return { ...res, only: merged };\n        });\n\n        // … and update the cache\n        entrypoint.addResolveTask(source, newTask);\n        return newTask;\n      }\n\n      const resolveTask = getResolveTask(source, importsOnly);\n\n      entrypoint.addResolveTask(source, resolveTask);\n\n      return resolveTask;\n    })\n  );\n\n  log('resolved %d imports', resolvedImports.length);\n\n  const filteredImports = filterUnresolved(entrypoint, resolvedImports);\n  emitDependency(eventEmitter, entrypoint, filteredImports);\n  return filteredImports;\n}\n"],"mappings":"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"}