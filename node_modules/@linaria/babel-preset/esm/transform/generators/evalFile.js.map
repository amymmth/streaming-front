{"version":3,"file":"evalFile.js","names":["evaluate","hasLinariaPreval","isUnprocessedEntrypointError","wrap","fn","e","evalFile","entrypoint","log","evaluated","undefined","services","linariaPreval","value","__linariaPreval","valueCache","Map","Object","entries","forEach","key","lazyValue","set","dependencies"],"sources":["../../../src/transform/generators/evalFile.ts"],"sourcesContent":["import type { ValueCache } from '@linaria/tags';\n\nimport type { IEvaluateResult } from '../../evaluators';\nimport evaluate from '../../evaluators';\nimport hasLinariaPreval from '../../utils/hasLinariaPreval';\nimport { isUnprocessedEntrypointError } from '../actions/UnprocessedEntrypointError';\nimport type { IEvalAction, SyncScenarioForAction } from '../types';\n\nconst wrap = <T>(fn: () => T): T | Error => {\n  try {\n    return fn();\n  } catch (e) {\n    return e as Error;\n  }\n};\n\n/**\n * Executes the code prepared in previous steps within the current `Entrypoint`.\n * Returns all exports that were requested in `only`.\n */\n// eslint-disable-next-line require-yield\nexport function* evalFile(\n  this: IEvalAction\n): SyncScenarioForAction<IEvalAction> {\n  const { entrypoint } = this;\n  const { log } = entrypoint;\n\n  log(`>> evaluate __linariaPreval`);\n\n  let evaluated: IEvaluateResult | undefined;\n\n  while (evaluated === undefined) {\n    try {\n      evaluated = evaluate(this.services, entrypoint);\n    } catch (e) {\n      if (isUnprocessedEntrypointError(e)) {\n        entrypoint.log(\n          'Evaluation has been aborted because one if the required files is not processed. Schedule reprocessing and repeat evaluation.'\n        );\n        yield ['processEntrypoint', e.entrypoint, undefined];\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  const linariaPreval = hasLinariaPreval(evaluated.value)\n    ? evaluated.value.__linariaPreval\n    : undefined;\n\n  if (!linariaPreval) {\n    return null;\n  }\n\n  const valueCache: ValueCache = new Map();\n  Object.entries(linariaPreval).forEach(([key, lazyValue]) => {\n    const value = wrap(lazyValue);\n    valueCache.set(key, value);\n  });\n\n  log(`<< evaluated __linariaPreval %O`, valueCache);\n\n  return [valueCache, evaluated.dependencies];\n}\n"],"mappings":"AAGA,OAAOA,QAAQ,MAAM,kBAAkB;AACvC,OAAOC,gBAAgB,MAAM,8BAA8B;AAC3D,SAASC,4BAA4B,QAAQ,uCAAuC;AAGpF,MAAMC,IAAI,GAAOC,EAAW,IAAgB;EAC1C,IAAI;IACF,OAAOA,EAAE,CAAC,CAAC;EACb,CAAC,CAAC,OAAOC,CAAC,EAAE;IACV,OAAOA,CAAC;EACV;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,UAAUC,QAAQA,CAAA,EAEa;EACpC,MAAM;IAAEC;EAAW,CAAC,GAAG,IAAI;EAC3B,MAAM;IAAEC;EAAI,CAAC,GAAGD,UAAU;EAE1BC,GAAG,CAAE,6BAA4B,CAAC;EAElC,IAAIC,SAAsC;EAE1C,OAAOA,SAAS,KAAKC,SAAS,EAAE;IAC9B,IAAI;MACFD,SAAS,GAAGT,QAAQ,CAAC,IAAI,CAACW,QAAQ,EAAEJ,UAAU,CAAC;IACjD,CAAC,CAAC,OAAOF,CAAC,EAAE;MACV,IAAIH,4BAA4B,CAACG,CAAC,CAAC,EAAE;QACnCE,UAAU,CAACC,GAAG,CACZ,8HACF,CAAC;QACD,MAAM,CAAC,mBAAmB,EAAEH,CAAC,CAACE,UAAU,EAAEG,SAAS,CAAC;MACtD,CAAC,MAAM;QACL,MAAML,CAAC;MACT;IACF;EACF;EAEA,MAAMO,aAAa,GAAGX,gBAAgB,CAACQ,SAAS,CAACI,KAAK,CAAC,GACnDJ,SAAS,CAACI,KAAK,CAACC,eAAe,GAC/BJ,SAAS;EAEb,IAAI,CAACE,aAAa,EAAE;IAClB,OAAO,IAAI;EACb;EAEA,MAAMG,UAAsB,GAAG,IAAIC,GAAG,CAAC,CAAC;EACxCC,MAAM,CAACC,OAAO,CAACN,aAAa,CAAC,CAACO,OAAO,CAAC,CAAC,CAACC,GAAG,EAAEC,SAAS,CAAC,KAAK;IAC1D,MAAMR,KAAK,GAAGV,IAAI,CAACkB,SAAS,CAAC;IAC7BN,UAAU,CAACO,GAAG,CAACF,GAAG,EAAEP,KAAK,CAAC;EAC5B,CAAC,CAAC;EAEFL,GAAG,CAAE,iCAAgC,EAAEO,UAAU,CAAC;EAElD,OAAO,CAACA,UAAU,EAAEN,SAAS,CAACc,YAAY,CAAC;AAC7C"}