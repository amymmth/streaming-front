/**
 * Collector traverses the AST and collects information about imports and
 * all Linaria template literals.
 */

import { debug } from '@linaria/logger';
import { invalidateTraversalCache, removeWithRelated } from '@linaria/utils';
import { processTemplateExpression } from '../utils/processTemplateExpression';
export const filename = __filename;
export function collector(file, options, values) {
  const processors = [];
  const identifiers = [];
  file.path.traverse({
    Identifier: p => {
      identifiers.push(p);
    }
  });

  // TODO: process transformed literals
  identifiers.forEach(p => {
    processTemplateExpression(p, file.opts, options, processor => {
      processor.build(values);
      processor.doRuntimeReplacement();
      processors.push(processor);
    });
  });
  if (processors.length === 0) {
    // We didn't find any Linaria template literals.
    return processors;
  }

  // We can remove __linariaPreval export and all related code
  const prevalExport = file.path.scope.getData('__linariaPreval')?.findParent(p => p.isExpressionStatement());
  if (prevalExport) {
    removeWithRelated([prevalExport]);
  }
  return processors;
}
export default function collectorPlugin(babel, options) {
  const values = options.values ?? new Map();
  return {
    name: '@linaria/babel/collector',
    pre(file) {
      debug('collect:start', file.opts.filename);
      const processors = collector(file, options, values);
      if (processors.length === 0) {
        // We didn't find any Linaria template literals.
        return;
      }
      this.file.metadata.linaria = {
        processors,
        replacements: [],
        rules: {},
        dependencies: []
      };
      debug('collect:end', file.opts.filename);
    },
    visitor: {},
    post(file) {
      invalidateTraversalCache(file.path);
    }
  };
}
//# sourceMappingURL=collector.js.map