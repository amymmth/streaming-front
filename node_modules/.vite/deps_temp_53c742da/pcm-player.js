import {
  __commonJS
} from "./chunk-V4OQ3NZ2.js";

// node_modules/pcm-player/dist/index.js
var require_dist = __commonJS({
  "node_modules/pcm-player/dist/index.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = global || self, global.PCMPlayer = factory());
    })(exports, function() {
      "use strict";
      class PCMPlayer {
        constructor(option) {
          this.init(option);
        }
        init(option) {
          const defaultOption = {
            inputCodec: "Int16",
            // 传入的数据是采用多少位编码，默认16位
            channels: 1,
            // 声道数
            sampleRate: 8e3,
            // 采样率 单位Hz
            flushTime: 1e3,
            // 缓存时间 单位 ms
            fftSize: 2048
            // analyserNode fftSize 
          };
          this.option = Object.assign({}, defaultOption, option);
          this.samples = new Float32Array();
          this.interval = setInterval(this.flush.bind(this), this.option.flushTime);
          this.convertValue = this.getConvertValue();
          this.typedArray = this.getTypedArray();
          this.initAudioContext();
          this.bindAudioContextEvent();
        }
        getConvertValue() {
          const inputCodecs = {
            "Int8": 128,
            "Int16": 32768,
            "Int32": 2147483648,
            "Float32": 1
          };
          if (!inputCodecs[this.option.inputCodec]) throw new Error("wrong codec.please input one of these codecs:Int8,Int16,Int32,Float32");
          return inputCodecs[this.option.inputCodec];
        }
        getTypedArray() {
          const typedArrays = {
            "Int8": Int8Array,
            "Int16": Int16Array,
            "Int32": Int32Array,
            "Float32": Float32Array
          };
          if (!typedArrays[this.option.inputCodec]) throw new Error("wrong codec.please input one of these codecs:Int8,Int16,Int32,Float32");
          return typedArrays[this.option.inputCodec];
        }
        initAudioContext() {
          this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          this.gainNode = this.audioCtx.createGain();
          this.gainNode.gain.value = 0.1;
          this.gainNode.connect(this.audioCtx.destination);
          this.startTime = this.audioCtx.currentTime;
          this.analyserNode = this.audioCtx.createAnalyser();
          this.analyserNode.fftSize = this.option.fftSize;
        }
        static isTypedArray(data) {
          return data.byteLength && data.buffer && data.buffer.constructor == ArrayBuffer || data.constructor == ArrayBuffer;
        }
        isSupported(data) {
          if (!PCMPlayer.isTypedArray(data)) throw new Error("请传入ArrayBuffer或者任意TypedArray");
          return true;
        }
        feed(data) {
          this.isSupported(data);
          data = this.getFormattedValue(data);
          const tmp = new Float32Array(this.samples.length + data.length);
          tmp.set(this.samples, 0);
          tmp.set(data, this.samples.length);
          this.samples = tmp;
        }
        getFormattedValue(data) {
          if (data.constructor == ArrayBuffer) {
            data = new this.typedArray(data);
          } else {
            data = new this.typedArray(data.buffer);
          }
          let float32 = new Float32Array(data.length);
          for (let i = 0; i < data.length; i++) {
            float32[i] = data[i] / this.convertValue;
          }
          return float32;
        }
        volume(volume) {
          this.gainNode.gain.value = volume;
        }
        destroy() {
          if (this.interval) {
            clearInterval(this.interval);
          }
          this.samples = null;
          this.audioCtx.close();
          this.audioCtx = null;
        }
        flush() {
          if (!this.samples.length) return;
          const self2 = this;
          var bufferSource = this.audioCtx.createBufferSource();
          if (typeof this.option.onended === "function") {
            bufferSource.onended = function(event) {
              self2.option.onended(this, event);
            };
          }
          const length = this.samples.length / this.option.channels;
          const audioBuffer = this.audioCtx.createBuffer(this.option.channels, length, this.option.sampleRate);
          for (let channel = 0; channel < this.option.channels; channel++) {
            const audioData = audioBuffer.getChannelData(channel);
            let offset = channel;
            let decrement = 50;
            for (let i = 0; i < length; i++) {
              audioData[i] = this.samples[offset];
              if (i < 50) {
                audioData[i] = audioData[i] * i / 50;
              }
              if (i >= length - 51) {
                audioData[i] = audioData[i] * decrement-- / 50;
              }
              offset += this.option.channels;
            }
          }
          if (this.startTime < this.audioCtx.currentTime) {
            this.startTime = this.audioCtx.currentTime;
          }
          bufferSource.buffer = audioBuffer;
          bufferSource.connect(this.gainNode);
          bufferSource.connect(this.analyserNode);
          bufferSource.start(this.startTime);
          this.startTime += audioBuffer.duration;
          this.samples = new Float32Array();
        }
        async pause() {
          await this.audioCtx.suspend();
        }
        async continue() {
          await this.audioCtx.resume();
        }
        bindAudioContextEvent() {
          const self2 = this;
          if (typeof self2.option.onstatechange === "function") {
            this.audioCtx.onstatechange = function(event) {
              self2.audioCtx && self2.option.onstatechange(this, event, self2.audioCtx.state);
            };
          }
        }
      }
      return PCMPlayer;
    });
  }
});
export default require_dist();
//# sourceMappingURL=pcm-player.js.map
