{
  "version": 3,
  "sources": ["../../pcm-player/dist/index.js"],
  "sourcesContent": ["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.PCMPlayer = factory());\n}(this, (function () { 'use strict';\n\n  class PCMPlayer {\n    constructor(option) {\n      this.init(option);\n    }\n\n    init(option) {\n      const defaultOption = {\n        inputCodec: 'Int16', // 传入的数据是采用多少位编码，默认16位\n        channels: 1, // 声道数\n        sampleRate: 8000, // 采样率 单位Hz\n        flushTime: 1000, // 缓存时间 单位 ms\n        fftSize: 2048 // analyserNode fftSize \n      };\n\n      this.option = Object.assign({}, defaultOption, option); // 实例最终配置参数\n      this.samples = new Float32Array(); // 样本存放区域\n      this.interval = setInterval(this.flush.bind(this), this.option.flushTime);\n      this.convertValue = this.getConvertValue();\n      this.typedArray = this.getTypedArray();\n      this.initAudioContext();\n      this.bindAudioContextEvent();\n    }\n\n    getConvertValue() {\n      // 根据传入的目标编码位数\n      // 选定转换数据所需要的基本值\n      const inputCodecs = {\n        'Int8': 128,\n        'Int16': 32768,\n        'Int32': 2147483648,\n        'Float32': 1\n      };\n      if (!inputCodecs[this.option.inputCodec]) throw new Error('wrong codec.please input one of these codecs:Int8,Int16,Int32,Float32')\n      return inputCodecs[this.option.inputCodec]\n    }\n\n    getTypedArray() {\n      // 根据传入的目标编码位数\n      // 选定前端的所需要的保存的二进制数据格式\n      // 完整TypedArray请看文档\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\n      const typedArrays = {\n        'Int8': Int8Array,\n        'Int16': Int16Array,\n        'Int32': Int32Array,\n        'Float32': Float32Array\n      };\n      if (!typedArrays[this.option.inputCodec]) throw new Error('wrong codec.please input one of these codecs:Int8,Int16,Int32,Float32')\n      return typedArrays[this.option.inputCodec]\n    }\n\n    initAudioContext() {\n      // 初始化音频上下文的东西\n      this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      // 控制音量的 GainNode\n      // https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/createGain\n      this.gainNode = this.audioCtx.createGain();\n      this.gainNode.gain.value = 0.1;\n      this.gainNode.connect(this.audioCtx.destination);\n      this.startTime = this.audioCtx.currentTime;\n      this.analyserNode = this.audioCtx.createAnalyser(); \n      this.analyserNode.fftSize = this.option.fftSize;\n    }\n\n    static isTypedArray(data) {\n      // 检测输入的数据是否为 TypedArray 类型或 ArrayBuffer 类型\n      return (data.byteLength && data.buffer && data.buffer.constructor == ArrayBuffer) || data.constructor == ArrayBuffer;\n    }\n\n    isSupported(data) {\n      // 数据类型是否支持\n      // 目前支持 ArrayBuffer 或者 TypedArray\n      if (!PCMPlayer.isTypedArray(data)) throw new Error('请传入ArrayBuffer或者任意TypedArray')\n      return true\n    }\n\n    feed(data) {\n      this.isSupported(data);\n\n      // 获取格式化后的buffer\n      data = this.getFormattedValue(data);\n      // 开始拷贝buffer数据\n      // 新建一个Float32Array的空间\n      const tmp = new Float32Array(this.samples.length + data.length);\n      // console.log(data, this.samples, this.samples.length)\n      // 复制当前的实例的buffer值（历史buff)\n      // 从头（0）开始复制\n      tmp.set(this.samples, 0);\n      // 复制传入的新数据\n      // 从历史buff位置开始\n      tmp.set(data, this.samples.length);\n      // 将新的完整buff数据赋值给samples\n      // interval定时器也会从samples里面播放数据\n      this.samples = tmp;\n      // console.log('this.samples', this.samples)\n    }\n\n    getFormattedValue(data) {\n      if (data.constructor == ArrayBuffer) {\n        data = new this.typedArray(data);\n      } else {\n        data = new this.typedArray(data.buffer);\n      }\n\n      let float32 = new Float32Array(data.length);\n\n      for (let i = 0; i < data.length; i++) {\n        // buffer 缓冲区的数据，需要是IEEE754 里32位的线性PCM，范围从-1到+1\n        // 所以对数据进行除法\n        // 除以对应的位数范围，得到-1到+1的数据\n        // float32[i] = data[i] / 0x8000;\n        float32[i] = data[i] / this.convertValue;\n      }\n      return float32\n    }\n\n    volume(volume) {\n      this.gainNode.gain.value = volume;\n    }\n\n    destroy() {\n      if (this.interval) {\n        clearInterval(this.interval);\n      }\n      this.samples = null;\n      this.audioCtx.close();\n      this.audioCtx = null;\n    }\n\n    flush() {\n      if (!this.samples.length) return\n      const self = this;\n      var bufferSource = this.audioCtx.createBufferSource();\n      if (typeof this.option.onended === 'function') {\n        bufferSource.onended = function (event) {\n          self.option.onended(this, event);\n        };\n      }\n      const length = this.samples.length / this.option.channels;\n      const audioBuffer = this.audioCtx.createBuffer(this.option.channels, length, this.option.sampleRate);\n\n      for (let channel = 0; channel < this.option.channels; channel++) {\n        const audioData = audioBuffer.getChannelData(channel);\n        let offset = channel;\n        let decrement = 50;\n        for (let i = 0; i < length; i++) {\n          audioData[i] = this.samples[offset];\n          /* fadein */\n          if (i < 50) {\n            audioData[i] = (audioData[i] * i) / 50;\n          }\n          /* fadeout*/\n          if (i >= (length - 51)) {\n            audioData[i] = (audioData[i] * decrement--) / 50;\n          }\n          offset += this.option.channels;\n        }\n      }\n\n      if (this.startTime < this.audioCtx.currentTime) {\n        this.startTime = this.audioCtx.currentTime;\n      }\n      // console.log('start vs current ' + this.startTime + ' vs ' + this.audioCtx.currentTime + ' duration: ' + audioBuffer.duration);\n      bufferSource.buffer = audioBuffer;\n      bufferSource.connect(this.gainNode);\n      bufferSource.connect(this.analyserNode); // bufferSource连接到analyser\n      bufferSource.start(this.startTime);\n      this.startTime += audioBuffer.duration;\n      this.samples = new Float32Array();\n    }\n\n    async pause() {\n      await this.audioCtx.suspend();\n    }\n\n    async continue() {\n      await this.audioCtx.resume();\n    }\n\n    bindAudioContextEvent() {\n      const self = this;\n      if (typeof self.option.onstatechange === 'function') {\n        this.audioCtx.onstatechange = function (event) {\n          self.audioCtx && self.option.onstatechange(this, event, self.audioCtx.state);\n        };\n      }\n    }\n\n  }\n\n  return PCMPlayer;\n\n})));\n"],
  "mappings": "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",
  "names": ["self"]
}
