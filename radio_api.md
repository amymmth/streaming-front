Протокол взаимодействия для варианта 2 (отправка аудио через вебсокеты)


Описание протокола
==================

Протокол построен поверх вебсокетов. 

Текстовые сообщения
-------------------

В текстовых сообщениях передается JSON формата

```json
{
	"message_type": "тип_сообщения",
	"payload": {
		... //специфическое тело сообщения, в зависимости от типа
	}
}
```

Бинарные сообщения
------------------

В бинарных сообщениях передается аудио-поток в соответствии с форматом, указанном в начальном (текстовом) сообщении сессии.
В бинарных сообщениях предполагаются только "сырые" аудио-данные, без дополнительной структуры (заголовков, и тп).

В сообщении должно передаваться корректное количество байтов, чтобы составлять целое количество аудио-сэмплов. Например, `PCM 16bit` предполагает 2 байта на сэмпл, так что количество байт в сообщении должно быть четным.


Порядок работы
==============


Инициация сессии
----------------

Клиент (бэк сайта) инициирует создание сессии, подключаясь к api воркера, выставленному на сервисе OCD: GET ws://hostname:port/session

После подключения клиент отправляет начальное (текстовое) сообщение типа `new_session`

```json
{
	"message_type": "new_session",
	"payload": {
		"station": 1,		//номер "станции", 1..3
		"knobs": [			//массив значений "ручек" из 3х элементов
			1.0,
			2.2,
			-0.3
		],
		"trace_id": "произвольный идентификатор, который поможет потом отличать запросы",
	}
}
```

в ответ воркер присылает сообщение `session_created` с ID сессии

```json
{
	"message_type": "session_created",
	"payload": {
		"session_id": "uuid", 			// ID сессии, по которому потом можно будет искать сессии в логах
		"format": "PCM_16b_41000hz", 	// Формат аудио, пока только "PCM_16b_41000hz"
	}
}
```

После этого воркер начинает отправлять аудио-пакеты в бинарных сообщениях в сторону клиента.

Изменение значения ручек
------------------------

В течение сессии, клиент может присылать изменения значений "ручек", в соответствии с действиями пользователя. Для этого он отправляет воркеру сообщение типа `update`:

```json
{
	"message_type": "update",
	"payload": {
		"knobs": [			//массив значений "ручек" из 3х элементов
			1.0,
			2.2,
			-0.3
		]
	}
}
```

Также пользователь может изменить "номер станции" без разрыва сессии, указав в том же сообщении `update` поле `station`:

```json
{
	"message_type": "update",
	"station": 2,
	"payload": {
		"knobs": [			//массив значений "ручек" из 3х элементов
			1.0,
			2.2,
			-0.3
		]
	}
}
```

Воркер применяет значения (это занимает какое-то время) и в процессе изменения значений присылает с некоторой периодичностью текущие актуальные значения в сообщении `status`:

```json
{
	"message_type": "status",
	"payload": {
		"station": 1,		//номер текущей станции
		"knobs": [			//массив значений "ручек" из 3х элементов
			1.0,
			2.2,
			-0.3
		]
	}
}
```

Завершение сессии
-----------------

Для прекращения сессии клиент отправляет текстовое сообщение `close_session`, и закрывает коннект со своей стороны.
```json
{
	"message_type": "close_session",
	"payload": { }
}
```


Поддержка актуальности соединения
---------------------------------

Для поддержания уверенности в том, что клиент не "отвалился", клиент с некоторой периодичностью (например, раз в 10 секунд) отправляет сообщение `ping`:

```json
{
	"message_type": "ping",
	"payload": {}
}
```

В ответ на него воркер присылает сообщение `pong`:

```json
{
	"message_type": "pong",
	"payload": {}
}
```

Если от клиента не приходят сообщения `ping` в течение некоторого таймаута (например `10 * 2` секунд), то сессия считается разорванной, воркер отправляет в сторону клиента сообщение `error` и закрывает подключение

```json
{
	"message_type": "error",
	"payload": { 
		"reason": "session_lost"
	}
}
```


Обработка ошибок воркера
------------------------ 

В случае обнаружения проблем на стороне воркера, он отправляет в сторону клиента сообщение `error` и закрывает подключение

```json
{
	"message_type": "error",
	"payload": { 
		"reason": "<some_reason>", 	//список причин нужно согласовать отдельно
	}
}
```